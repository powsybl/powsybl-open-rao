/*
 * Copyright (c) 2020, RTE (http://www.rte-france.com)
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
package com.powsybl.openrao.searchtreerao.commons.parameters;

import com.powsybl.openrao.raoapi.parameters.ObjectiveFunctionParameters;
import com.powsybl.openrao.raoapi.parameters.extensions.SearchTreeRaoRangeActionsOptimizationParameters;
import com.powsybl.openrao.raoapi.parameters.RaoParameters;

import static com.powsybl.openrao.raoapi.parameters.extensions.MultithreadingParameters.*;
import static com.powsybl.openrao.raoapi.parameters.extensions.SearchTreeRaoObjectiveFunctionParameters.getCurativeMinObjImprovement;
import static com.powsybl.openrao.raoapi.parameters.extensions.SearchTreeRaoRangeActionsOptimizationParameters.getRaRangeShrinking;
import static com.powsybl.openrao.raoapi.parameters.extensions.SearchTreeRaoTopoOptimizationParameters.*;

/**
 * This class contains internal Open RAO parameters used in the SearchTree algorithm.
 * These parameters are dynamically generated by the SearchTreeRaoProvider depending on the context and on
 * the user's RAO parameters, and then used in SearchTree algorithm.
 * They should not be visible to the user.
 *
 * @author Peter Mitri {@literal <peter.mitri at rte-france.com>}
 */
public record TreeParameters(StopCriterion stopCriterion, double targetObjectiveValue, int maximumSearchDepth, int leavesInParallel, boolean raRangeShrinking) {

    public enum StopCriterion {
        MIN_OBJECTIVE,
        AT_TARGET_OBJECTIVE_VALUE
    }

    public static TreeParameters buildForPreventivePerimeter(RaoParameters parameters) {
        SearchTreeRaoRangeActionsOptimizationParameters.RaRangeShrinking raRangeShrinking = getRaRangeShrinking(parameters);
        boolean shouldShrinkRaRange = raRangeShrinking.equals(SearchTreeRaoRangeActionsOptimizationParameters.RaRangeShrinking.ENABLED_IN_FIRST_PRAO_AND_CRAO) ||
            raRangeShrinking.equals(SearchTreeRaoRangeActionsOptimizationParameters.RaRangeShrinking.ENABLED);
        if (parameters.getObjectiveFunctionParameters().getType() == ObjectiveFunctionParameters.ObjectiveFunctionType.SECURE_FLOW) {
            return new TreeParameters(StopCriterion.AT_TARGET_OBJECTIVE_VALUE,
                0.0, // secure
                getMaxPreventiveSearchTreeDepth(parameters),
                getAvailableCPUs(parameters),
                shouldShrinkRaRange);
        } else {
            return new TreeParameters(StopCriterion.MIN_OBJECTIVE,
                0.0, // value does not matter
                getMaxPreventiveSearchTreeDepth(parameters),
                getAvailableCPUs(parameters),
                shouldShrinkRaRange);
        }
    }

    public static TreeParameters buildForAutomatonPerimeter(RaoParameters parameters) {
        return new TreeParameters(StopCriterion.AT_TARGET_OBJECTIVE_VALUE, 0.0, getMaxAutoSearchTreeDepth(parameters), 1, false);
    }

    public static TreeParameters buildForCurativePerimeter(RaoParameters parameters, Double preventiveOptimizedCost) {
        StopCriterion stopCriterion = StopCriterion.AT_TARGET_OBJECTIVE_VALUE;
        double targetObjectiveValue;
        if (parameters.getObjectiveFunctionParameters().getType() == ObjectiveFunctionParameters.ObjectiveFunctionType.SECURE_FLOW) {
            targetObjectiveValue = 0.0;
        } else {
            targetObjectiveValue = preventiveOptimizedCost - getCurativeMinObjImprovement(parameters);
            if (parameters.getObjectiveFunctionParameters().getEnforceCurativeSecurity()) {
                targetObjectiveValue = Math.min(targetObjectiveValue, 0);
            }
        }
        SearchTreeRaoRangeActionsOptimizationParameters.RaRangeShrinking raRangeShrinking = getRaRangeShrinking(parameters);
        boolean shouldShrinkRaRange = raRangeShrinking.equals(SearchTreeRaoRangeActionsOptimizationParameters.RaRangeShrinking.ENABLED_IN_FIRST_PRAO_AND_CRAO) ||
            raRangeShrinking.equals(SearchTreeRaoRangeActionsOptimizationParameters.RaRangeShrinking.ENABLED);
        return new TreeParameters(stopCriterion,
            targetObjectiveValue,
            getMaxCurativeSearchTreeDepth(parameters),
            1,
            shouldShrinkRaRange);
    }

    public static TreeParameters buildForSecondPreventivePerimeter(RaoParameters parameters) {
        boolean raRangeShrinking = getRaRangeShrinking(parameters).equals(SearchTreeRaoRangeActionsOptimizationParameters.RaRangeShrinking.ENABLED);
        if (parameters.getObjectiveFunctionParameters().getType().equals(ObjectiveFunctionParameters.ObjectiveFunctionType.SECURE_FLOW)) {
            return new TreeParameters(StopCriterion.AT_TARGET_OBJECTIVE_VALUE,
                0.0, // secure
                getMaxPreventiveSearchTreeDepth(parameters),
                getAvailableCPUs(parameters),
                raRangeShrinking);
        } else {
            return new TreeParameters(StopCriterion.MIN_OBJECTIVE,
                0.0, // value does not matter
                getMaxPreventiveSearchTreeDepth(parameters),
                getAvailableCPUs(parameters),
                raRangeShrinking);
        }
    }
}
