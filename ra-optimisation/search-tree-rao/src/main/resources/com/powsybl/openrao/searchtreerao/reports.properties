# Keys must be alphabetically ordered
openrao.searchtreerao.reportAssigningVirtualCostToSensitivityFailure = Sensitivity failure : assigning virtual overcost of ${sensitivityFailureOvercost}
openrao.searchtreerao.reportAssigningVirtualCostToSensitivityFailureForState = Sensitivity failure for state ${stateId} : assigning virtual overcost of ${sensitivityFailureOvercost}
openrao.searchtreerao.reportAutomatonSimulationFailedRangeActionSensitivityComputation = Automaton state ${automatonStateId} has failed during sensitivity computation ${failDescription}
openrao.searchtreerao.reportAutomatonSkipped = Automaton ${networkActionId} - ${networkActionName} has been skipped as it has no impact on network.
openrao.searchtreerao.reportAutomatonStateOptimized = Automaton state ${automatonStateId} has been optimized.
openrao.searchtreerao.reportBestLeaf = Best leaf: ${leaf}
openrao.searchtreerao.reportBestLeafNoRangeActionActivated = Best leaf: No range actions activated
openrao.searchtreerao.reportBestLeafRangeActionsActivated = Best leaf: Range action(s): ${rangeActions}
openrao.searchtreerao.reportCanNotOptimizeRemedialActionCombination = Cannot optimize remedial action combination ${id}: ${errorMessage}
openrao.searchtreerao.reportCastorInitialSensitivityAnalysisResults = Initial sensitivity analysis: cost = ${cost} (functional: ${functionalCost}, virtual: ${virtualCost}${virtualCostDetail})
openrao.searchtreerao.reportCastorOneStateOnly = Castor one state only
openrao.searchtreerao.reportCastorSystematicSensitivityAnalysisAfterCraResults = Systematic sensitivity analysis after curative remedial actions before second preventive optimization: cost = ${cost} (functional: ${functionalCost}, virtual: ${virtualCost}${virtualCostDetail})
openrao.searchtreerao.reportCastorSystematicSensitivityAnalysisAfterPraResults = Systematic sensitivity analysis after preventive remedial actions: cost = ${cost} (functional: ${functionalCost}, virtual: ${virtualCost}${virtualCostDetail})
openrao.searchtreerao.reportContingencyScenariosToRegulate = ${nbContingencies} contingency scenario(s) to regulate: ${contingenciesList}
openrao.searchtreerao.reportContingencyWithAutomatonOrCraButNoCnec = Contingency ${contingencyId} has an automaton or a curative remedial action but no CNECs associated.
openrao.searchtreerao.reportCostOf = ${costName} cost of ${cost}
openrao.searchtreerao.reportCostNotIncreasedDuringRao = Cost has not increased during RAO, there is no need to run a 2nd preventive RAO.
openrao.searchtreerao.reportCostsBeforeAndAfterRao = Cost before RAO = ${initialCost} (functional: ${initialFunctionalCost}, virtual: ${initialVirtualCost}${initialVirtualCostDetail}), cost after RAO = ${finalCost} (functional: ${finalFunctionalCost}, virtual: ${finalVirtualCost}${finalVirtualCostDetail})
openrao.searchtreerao.reportCouldNotEvaluateLeaf = Could not evaluate leaf: ${leaf}
openrao.searchtreerao.reportCouldNotEvaluateNetworkActionCombination = Could not evaluate network action combination "${networkActions}": ${exceptionMessage}
openrao.searchtreerao.reportCurativePerimeterOptimization = Curative perimeter optimization
openrao.searchtreerao.reportCurativeStateOptimized = Curative state ${stateId} has been optimized.
openrao.searchtreerao.reportErrorDuringPstRegulation = An error occurred during PST regulation, pre-regulation RAO result will be kept.
openrao.searchtreerao.reportEvaluatedLeaf = Evaluated ${leaf}
openrao.searchtreerao.reportExceptionMessage = ${exceptionMessage}
openrao.searchtreerao.reportExceptionMessageAndStacktrace = ${exceptionMessage} \n ${stackTrace}
openrao.searchtreerao.reportFailedOptimizationSummary = Scenario "${scenarioName}": ${raResult}
openrao.searchtreerao.reportFailedToEvaluateLeafSensiFailed = Failed to evaluate leaf: sensitivity analysis failed
openrao.searchtreerao.reportFailedToOptimizeLeaf = Failed to optimize leaf: ${leaf}
openrao.searchtreerao.reportFastRaoDoesNotSupportMultiCurativeOptimization = Fast Rao does not support multi-curative optimization
openrao.searchtreerao.reportFastRaoDoesNotSupportOptimizationOnOneGivenStateOnly = Fast Rao does not support optimization on one given state only
openrao.searchtreerao.reportFastRaoFinalResult = [FAST RAO] Final Result: cost = ${cost} (functional: ${functionalCost}, virtual: ${virtualCost}${virtualCostDetail})
openrao.searchtreerao.reportFastRaoInitialSensitivityAnalysisResults = [FAST RAO] Initial sensitivity analysis: cost = ${cost} (functional: ${functionalCost}, virtual: ${virtualCost}${virtualCostDetail})
openrao.searchtreerao.reportFastRaoIteration = [FAST RAO] Iteration ${iterationCounter}
openrao.searchtreerao.reportFastRaoIterationIntermediateResult = [FAST RAO] Sensitivity analysis: cost = ${cost} (functional: ${functionalCost}, virtual: ${virtualCost}${virtualCostDetail})
openrao.searchtreerao.reportFastRaoIterationRunFilteredRao = [FAST RAO] Run filtered RAO with ${nbCnecsToKeep}/${nbCnecsInCrac} cnecs
openrao.searchtreerao.reportFastRaoIterationRunFullSensitivityAnalysis = [FAST RAO] Run full sensitivity analysis
openrao.searchtreerao.reportFoundMoreAcEmulationDeactivationActionThanExpected = Expected exactly one acEmulationDeactivationAction for HVDC line ${hvdcLineId}, but found ${nbActions}.
openrao.searchtreerao.reportHeterogenousRangeActionGroupTypes = Range action group ${groupId} contains range actions of different types; they are not simulated
openrao.searchtreerao.reportHvdcLineSetpointNotUpdated = HVDC line ${hvdcLineId} active setpoint could not be updated because its new set-point (${activePowerSetpoint}) does not fall within its allowed range (${minAdmissibleSetpoint} - ${maxAdmissibleSetpoint})
openrao.searchtreerao.reportIfMostLimitingElementIsFictional = Limiting element is a fictional CNEC that is excluded from final cost computation
openrao.searchtreerao.reportImpossibleToOptimizeLeafBecauseEvaluationFailed = Impossible to optimize leaf: ${leaf} because evaluation failed
openrao.searchtreerao.reportImpossibleToOptimizeLeafBecauseEvaluationNotPerformed = Impossible to optimize leaf: ${leaf} because evaluation has not been performed
openrao.searchtreerao.reportInitialSensitivityAnalysisFailed = Initial sensitivity analysis failed
openrao.searchtreerao.reportInitialSituation = Initial situation
openrao.searchtreerao.reportInitialSituationMostLimitingElements = Limiting element #${limitingElementIndex}:${isRelativeMargin} margin = ${roundedCnecMargin} ${unit}${ptdfIfRelative}, element ${cnecNetworkElementName} at state ${cnecStateId}, CNEC ID = "${cnecId}"
openrao.searchtreerao.reportLeafOptimization = Optimizing leaf with network actions combination: ${naCombinationIds}
openrao.searchtreerao.reportLeavesToEvaluate = Leaves to evaluate: ${nbLeaves}
openrao.searchtreerao.reportLinearOptimFoundBetterSolution = Iteration ${iteration}: better solution found with a cost of ${cost} (functional: ${functionalCost})
openrao.searchtreerao.reportLinearOptimFoundWorseResult = Iteration ${iteration}: linear optimization found a worse result than best iteration, with a cost increasing from ${bestResultCost} to ${currentResultCost} (functional: from ${bestResultFunctionalCost} to ${currentResultFunctionalCost})
openrao.searchtreerao.reportLinearOptimizationFailedAtIteration = Linear optimization failed at iteration ${iteration}
openrao.searchtreerao.reportLinearOptimizationOnRootLeaf = Linear optimization on root leaf
openrao.searchtreerao.reportLinearProblemFailedWithStatus = Linear problem failed with the following status : ${status}, initial situation is kept.
openrao.searchtreerao.reportLoopflowComputationLacksReferenceProgramOrGlskProvider = Loopflow computation cannot be performed on CRAC ${cracId} because it lacks a ReferenceProgram or a GlskProvider
openrao.searchtreerao.reportLoopflowConstraintsNotRespected = Some loopflow constraints are not respected.
openrao.searchtreerao.reportMarmotApplyingOptimalTopologicalActionsOnNetworks = [MARMOT] Applying optimal topological actions on networks
openrao.searchtreerao.reportMarmotCnecs = [MARMOT] Proceeding to next iteration by adding ${nbAddedCnecs} cnecs across ${nbTimestamps} timestamps
openrao.searchtreerao.reportMarmotCnecsForTimestampAndVirtualCost = for timestamp ${timestamp} and virtual cost ${vcName}: ${addedCnecs}
openrao.searchtreerao.reportMarmotEvaluatingGlobalResultAfterIndependentOptimizations = [MARMOT] Evaluating global result after independent optimizations
openrao.searchtreerao.reportMarmotGlobalRangeActionsOptimization = [MARMOT] Global range actions optimization
openrao.searchtreerao.reportMarmotGlobalRangeActionsOptimizationForIteration = [MARMOT] Global range actions optimization for iteration ${iteration}
openrao.searchtreerao.reportMarmotMergingTopoAndLinearRemedialActionResults = [MARMOT] Merging topological and linear remedial action results
openrao.searchtreerao.reportMarmotNextIterationOfMip = [MARMOT] Next iteration of MIP: cost = ${cost} (functional: ${functionalCost}, virtual: ${virtualCost}${virtualCostDetail})
openrao.searchtreerao.reportMarmotNoInterTemporalConstraintProvided = [MARMOT] No inter-temporal constraint provided; no need to re-optimize range actions
openrao.searchtreerao.reportMarmotNoPreventiveTopologicalActionsAppliedForTimestamp = [MARMOT] No preventive topological actions applied for timestamp ${timestamp}
openrao.searchtreerao.reportMarmotResultAfterGlobalLinearOptimization = [MARMOT] After global linear optimization: cost = ${cost} (functional: ${functionalCost}, virtual: ${virtualCost}${virtualCostDetail})
openrao.searchtreerao.reportMarmotResultBeforeGlobalLinearOptimization = [MARMOT] Before global linear optimization: cost = ${cost} (functional: ${functionalCost}, virtual: ${virtualCost}${virtualCostDetail})
openrao.searchtreerao.reportMarmotResultBeforeTopologicalOptimization = [MARMOT] Before topological optimizations: cost = ${cost} (functional: ${functionalCost}, virtual: ${virtualCost}${virtualCostDetail})
openrao.searchtreerao.reportMarmotRunRaoForTimestamp = [MARMOT] Running RAO for timestamp ${timestamp}
openrao.searchtreerao.reportMarmotSystematicInterTemporalSensitivityAnalysis = [MARMOT] Systematic inter-temporal sensitivity analysis
openrao.searchtreerao.reportMarmotTopologicalOptimization = [MARMOT] Topological optimization
openrao.searchtreerao.reportMaxSearchDepthReached = Maximum search depth has been reached, exiting search tree
openrao.searchtreerao.reportMergingFirstSecondPreventiveAndPostContingencyRaoResults = Merging first, second preventive and post-contingency RAO results
openrao.searchtreerao.reportMergingPreventiveAndPostContingencyRaoResults = Merging preventive and post-contingency RAO results
openrao.searchtreerao.reportMergingRaoAndPstRegulationResults = Merging RAO and PST regulation results
openrao.searchtreerao.reportMissingFastRaoParametersExtension = Parameters are missing FastRaoParameters extension. Default FastRaoParameters will be used
openrao.searchtreerao.reportMnecConstraintsNotRespected = Some MNEC constraints are not respected.
openrao.searchtreerao.reportMostLimitingElements = Most limiting elements: Worst margin = ${roundedCnecMargin}${unit}
openrao.searchtreerao.reportNetworkActionCombinationsFilteredOutMaxElementaryActionsExceeded = ${nbOfCombinations} network action combinations have been filtered out because the maximum number of elementary actions has been exceeded for one of its operators
openrao.searchtreerao.reportNetworkActionCombinationsFilteredOutMaxNetworkActionsReached = ${nbOfCombinations} network action combinations have been filtered out because the maximum number of network actions for their TSO has been reached
openrao.searchtreerao.reportNetworkActionCombinationsFilteredOutMaxUsableRasReached = ${nbOfCombinations} network action combinations have been filtered out because the max number of usable RAs has been reached
openrao.searchtreerao.reportNetworkActionCombinationsFilteredOutMaxUsableTsosReached = ${nbOfCombinations} network action combinations have been filtered out because the max number of usable TSOs has been reached
openrao.searchtreerao.reportNetworkActionCombinationsFilteredOutTooFar = ${nbOfCombinations} network action combinations have been filtered out because they are too far from the most limiting element
openrao.searchtreerao.reportNoBetterResultFoundInSearchDepth = No better result found in search depth ${depth}, exiting search tree
openrao.searchtreerao.reportNoDefaultRegulationTerminalDefined = No default regulation terminal defined for phase tap changer of two-windings transformer {twtId}, terminal on side ${limitingSide} will be used.
openrao.searchtreerao.reportNoDefaultTargetDeadbandDefined = No default target deadband defined for phase tap changer of two-windings transformer ${twtId}, a value of 0.0 will be used.
openrao.searchtreerao.reportNoGlskFoundForCountryEICode = No GLSK found for CountryEICode ${eiCode}
openrao.searchtreerao.reportNoMoreNetworkActionAvailable = No more network action available
openrao.searchtreerao.reportNoNetworkActionAvailable = No network action available
openrao.searchtreerao.reportNoRangeActionActivated = No range actions activated
openrao.searchtreerao.reportNoRangeActionToOptimize = No range actions to optimize
openrao.searchtreerao.reportNoRangeActionToOptimizeAfterFilteringHvdcRangeActions = No range actions to optimize after filtering HVDC range actions
openrao.searchtreerao.reportNoReferenceProgramProvided = No ReferenceProgram provided. A ReferenceProgram will be generated using information in the network file.
openrao.searchtreerao.reportNotEnoughTimeToRunSecondPreventiveRao = There is not enough time to run a 2nd preventive RAO (target end time: ${targetEndInstant}, estimated time needed based on first preventive RAO: ${estimatedPreventiveRaoTimeInSeconds} seconds)
openrao.searchtreerao.reportOptimizedLeaf = Optimized ${leaf}
openrao.searchtreerao.reportOptimizationSummaryWithInitialCost = Scenario "${scenarioName}": initial cost = ${initialCost} (functional: ${initialFunctionalCost}, virtual: ${initialVirtualCost}${initialVirtualCostDetail}), ${raResult}, cost after ${optimizedStateInstant} optimization = ${finalCost} (functional: ${finalFunctionalCost}, virtual: ${finalVirtualCost}${finalVirtualCostDetail})
openrao.searchtreerao.reportOptimizationSummaryWithoutInitialCost = Scenario "${scenarioName}": ${raResult}, cost after ${optimizedStateInstant} optimization = ${finalCost} (functional: ${finalFunctionalCost}, virtual: ${finalVirtualCost}${finalVirtualCostDetail})
openrao.searchtreerao.reportOptimizingAutomatonState = Optimizing automaton state ${automatonStateId}.
openrao.searchtreerao.reportOptimizingCurativeState = Optimizing curative state ${stateId}.
openrao.searchtreerao.reportOptimizingScenarioForContingency = Simulating and optimizing contingency scenario for contingency '${contingencyId}'
openrao.searchtreerao.reportOptimizingScenarioPostContingency = Optimizing scenario post-contingency ${contingencyId}.
openrao.searchtreerao.reportPostContingencyPerimeterOptimization = Post-contingency perimeters optimization
openrao.searchtreerao.reportPostPraSensiAnalysis = Post-PRA sensitivity analysis
openrao.searchtreerao.reportPredefinedCombinationShouldContainAtLeast2NetworkActionIds = A predefined combination should contain at least 2 NetworkAction ids
openrao.searchtreerao.reportPreventivePerimeterNotSecure = Preventive perimeter could not be secured; there is no point in optimizing post-contingency perimeters. The RAO will be interrupted here.
openrao.searchtreerao.reportPreventivePerimeterOptimization = Preventive perimeter optimization
openrao.searchtreerao.reportPstCannotBeRegulated = PST ${pstId} cannot be regulated as no curative PST range action was defined for it.
openrao.searchtreerao.reportPstsMustBeApproximatedAsIntegers = The PSTs must be approximated as integers to use the limitations of elementary actions as a constraint in the RAO.
openrao.searchtreerao.reportPstRegulation = PST regulation
openrao.searchtreerao.reportPstRegulationTriggeredDueToOverloadedFlowCnec = FlowCNEC '${flowCnec}' of contingency scenario '${contingency}' is overloaded and is the most limiting element, PST regulation has been triggered: ${allShiftedPstsDetails}
openrao.searchtreerao.reportPstsToRegulate = ${nbPsts} PST(s) to regulate: ${pstsList}
openrao.searchtreerao.reportRangeActionGroupNotAllAvailableAtAutoInstant = Range action group ${groupId} contains range actions not all available at AUTO instant; they are not simulated
openrao.searchtreerao.reportRangeActionInitialSetpointDoesNotRespectAllowedRange = Range action ${rangeActionId} has an initial setpoint of ${initialSetPoint} that does not respect its allowed range [${minSetPoint} ${maxSetPoint}]. It will be filtered out of the linear problem.
openrao.searchtreerao.reportRangeActionsActivated = Range action(s): ${rangeActions}
openrao.searchtreerao.reportRangeActionsOfGroupDoNotHaveSamePrePerimeterSetpoint = Range actions of group ${groupId} do not have the same prePerimeter setpoint. They will be filtered out of the linear problem.
openrao.searchtreerao.reportRaoFailure = Optimizing state "${stateId}" failed: ${exception}
openrao.searchtreerao.reportRaoIncreasedOverallCost = RAO has increased the overall cost from ${initialCost} (functional: ${initialFunctionalCost}, virtual: ${initialVirtualCost}) to ${finalCost} (functional: ${finalFunctionalCost}, virtual: ${finalVirtualCost}). Falling back to initial solution.
openrao.searchtreerao.reportRemainingLeavesToEvaluate = Remaining leaves to evaluate: ${nbLeaves}
openrao.searchtreerao.reportRootLeaf = ${rootLeaf}
openrao.searchtreerao.reportRunPostRangeSensitivityAnalysisForStateAndSpeed = Running post range automatons sensitivity analysis after auto state ${automatonStateId} for speed ${speed}.
openrao.searchtreerao.reportRunSensitivityAnalysisAfterDisablingAngleDroopActivePowerControlOnHvdcRa = Running sensitivity analysis after disabling AngleDroopActivePowerControl on HVDC RAs.
openrao.searchtreerao.reportRunSensitivityAnalysisPostApplicationForStateAndSpeed = Running sensitivity analysis post application of auto network actions for automaton state ${automatonStateId} for speed ${speed}.
openrao.searchtreerao.reportSameResultAsPreviousIterations = Iteration ${iteration}: same results as previous iterations, optimal solution found
openrao.searchtreerao.reportSearchDepth = Search depth ${depth}
openrao.searchtreerao.reportSearchDepthBestLeaf = Search depth ${depth} best leaf: ${leaf}
openrao.searchtreerao.reportSecondAutomatonSimulation = Second automaton simulation
openrao.searchtreerao.reportSecondPreventiveCancelledToSaveComputationTime = First preventive RAO was not able to fix all preventive constraints, second preventive RAO cancelled to save computation time.
openrao.searchtreerao.reportSecondPreventiveFailed = Second preventive failed. Falling back to previous solution.
openrao.searchtreerao.reportSecondPreventiveIncreasedOverallCost = Second preventive step has increased the overall cost from ${firstPreventiveCost} (functional: ${firstPreventiveFunctionalCost}, virtual: ${firstPreventiveVirtualCost}) to ${secondPreventiveCost} (functional: ${secondPreventiveFunctionalCost}, virtual: ${secondPreventiveVirtualCost}). Falling back to previous solution.
openrao.searchtreerao.reportSecondPreventiveMadeRaoSucceed = RAO has succeeded thanks to second preventive step when first preventive step had failed
openrao.searchtreerao.reportSecondPreventivePerimeterOptimization = Second preventive perimeter optimization
openrao.searchtreerao.reportSecondPreventivePerimeterOptimizationEnd = End of second preventive perimeter optimization
openrao.searchtreerao.reportSecondPreventivePerimeterOptimizationStart = Starting second preventive perimeter optimization
openrao.searchtreerao.reportSearchDepthBestLeafNoRangeActionActivated = Search depth ${depth} best leaf: No range actions activated
openrao.searchtreerao.reportSearchDepthBestLeafRangeActionsActivated = Search depth ${depth} best leaf: Range action(s): ${rangeActions}
openrao.searchtreerao.reportSearchTreeRaoCompletedWithStatus = Search-tree RAO completed with status ${status}
openrao.searchtreerao.reportSimulatingAutomatonBatch = Simulating automaton batch of speed ${speed} for automaton state ${automatonStateId}
openrao.searchtreerao.reportSkippingOptimization = Skipping ${id} optimization because earlier combination fulfills stop criterion.
openrao.searchtreerao.reportSolverInterrupted = The solver was interrupted. A feasible solution has been produced.
openrao.searchtreerao.reportStopCriterionCouldHaveBeenReachedWithoutVirtualCostOptimized = Optimized ${leaf}, stop criterion could have been reached without "${virtualCostName}" virtual cost
openrao.searchtreerao.reportStopCriterionCouldHaveBeenReachedWithoutVirtualCost = ${leaf}, stop criterion could have been reached without "${virtualCostName}" virtual cost
openrao.searchtreerao.reportStopCriterionReached = Stop criterion reached, other threads may skip optimization.
openrao.searchtreerao.reportStopCriterionReachedOnLeaf = Stop criterion reached on ${leaf}
openrao.searchtreerao.reportSystematicSensitivityAnalysisAfterCraAfterSecondPreventiveFailed = Systematic sensitivity analysis after curative remedial actions after second preventive optimization failed
openrao.searchtreerao.reportSystematicSensitivityAnalysisAfterPraAfterSecondPreventiveFailed = Systematic sensitivity analysis after preventive remedial actions after second preventive optimization failed
openrao.searchtreerao.reportSystematicSensitivityAnalysisAfterPraFailed = Systematic sensitivity analysis after preventive remedial actions failed
openrao.searchtreerao.reportSystematicSensitivityComputationFailedAtIteration = Systematic sensitivity computation failed at iteration ${iteration}
openrao.searchtreerao.reportThresholdForFlowCnecDefinedInMwButLoadflowComputationIsInAc = A threshold for the flowCnec ${flowCnecId} is defined in MW but the loadflow computation is in AC. It will be imprecisely converted by the RAO which could create uncoherent results due to side effects
openrao.searchtreerao.reportUnknownNetworkActionIdInPredefinedCombinationsParameter = Unknown network action id in predefined-combinations parameter: ${networkActionId}
openrao.searchtreerao.reportVirtualCostlyElement = ${leafId}, limiting "${virtualCostName}" constraint #${costlyElementIndex}: flow = ${flow} ${flowUnit}, threshold = ${threshold} ${thresholdUnit}, margin = ${margin} ${marginUnit}, element ${networkElement} at state ${state}, CNEC ID = "${cnecId}", CNEC name = "${cnecName}"
openrao.searchtreerao.reportVirtualCostlyElementOptimized = Optimized ${leafId}, limiting "${virtualCostName}" constraint #${costlyElementIndex}: flow = ${flow} ${flowUnit}, threshold = ${threshold} ${thresholdUnit}, margin = ${margin} ${marginUnit}, element ${networkElement} at state ${state}, CNEC ID = "${cnecId}", CNEC name = "${cnecName}"
