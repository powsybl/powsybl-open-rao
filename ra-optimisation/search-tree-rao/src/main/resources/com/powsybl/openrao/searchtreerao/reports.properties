# Keys must be alphabetically ordered
openrao.searchtreerao.reportAssigningVirtualCostToSensitivityFailure = Sensitivity failure : assigning virtual overcost of ${sensitivityFailureOvercost}
openrao.searchtreerao.reportAssigningVirtualCostToSensitivityFailureForState = Sensitivity failure for state ${stateId} : assigning virtual overcost of ${sensitivityFailureOvercost}
openrao.searchtreerao.reportAutomatonActivated = Activating automaton ${networkActionId} - ${networkActionName}.
openrao.searchtreerao.reportAutomatonSimulationFailedRangeActionSensitivityComputation = Automaton state ${automatonStateId} has failed during sensitivity computation ${failDescription}
openrao.searchtreerao.reportAutomatonSkipped = Automaton ${networkActionId} - ${networkActionName} has been skipped as it has no impact on network.
openrao.searchtreerao.reportAutomatonStateOptimized = Automaton state ${automatonStateId} has been optimized.
openrao.searchtreerao.reportBestLeaf = Best leaf: ${leaf}
openrao.searchtreerao.reportBestLeafNoRangeActionActivated = Best leaf: No range actions activated
openrao.searchtreerao.reportBestLeafRangeActionsActivated = Best leaf: Range action(s): ${rangeActions}
openrao.searchtreerao.reportCanNotOptimizeRemedialActionCombination = Cannot optimize remedial action combination ${id}: ${errorMessage}
openrao.searchtreerao.reportCastorFullOptimization = Castor full optimization
openrao.searchtreerao.reportCastorInitialSensitivityAnalysisResults = Initial sensitivity analysis: cost = ${cost} (functional: ${functionalCost}, virtual: ${virtualCost}${virtualCostDetail})
openrao.searchtreerao.reportCastorOneStateOnly = Castor one state only
openrao.searchtreerao.reportCastorSystematicSensitivityAnalysisAfterCraResults = Systematic sensitivity analysis after curative remedial actions before second preventive optimization: cost = ${cost} (functional: ${functionalCost}, virtual: ${virtualCost}${virtualCostDetail})
openrao.searchtreerao.reportCastorSystematicSensitivityAnalysisAfterPraResults = Systematic sensitivity analysis after preventive remedial actions: cost = ${cost} (functional: ${functionalCost}, virtual: ${virtualCost}${virtualCostDetail})
openrao.searchtreerao.reportContingencyWithAutomatonOrCraButNoCnec = Contingency ${contingencyId} has an automaton or a curative remedial action but no CNECs associated.
openrao.searchtreerao.reportCostOf = ${costName} cost of ${cost}
openrao.searchtreerao.reportCostNotIncreasedDuringRao = Cost has not increased during RAO, there is no need to run a 2nd preventive RAO.
openrao.searchtreerao.reportCostsBeforeAndAfterRao = Cost before RAO = ${initialCost} (functional: ${initialFunctionalCost}, virtual: ${initialVirtualCost}${initialVirtualCostDetail}), cost after RAO = ${finalCost} (functional: ${finalFunctionalCost}, virtual: ${finalVirtualCost}${finalVirtualCostDetail})
openrao.searchtreerao.reportCouldNotEvaluateLeaf = Could not evaluate leaf: ${leaf}
openrao.searchtreerao.reportCouldNotEvaluateNetworkActionCombination = Could not evaluate network action combination "${networkActions}": ${exceptionMessage}
openrao.searchtreerao.reportCurativePerimeterOptimization = Curative perimeter optimization
openrao.searchtreerao.reportCurativeStateOptimized = Curative state ${stateId} has been optimized.
openrao.searchtreerao.reportDisablingAngleDroopActivePowerControl = Disabling HvdcAngleDroopActivePowerControl on HVDC line ${hvdcLineId} and setting its set-point to ${activePowerSetpoint}
openrao.searchtreerao.reportEvaluatedLeaf = Evaluated ${leaf}
openrao.searchtreerao.reportEvaluatingLeaf = Evaluating ${leaf}
openrao.searchtreerao.reportEvaluatingNbLeavesInParallel = Evaluating ${nbLeaves} leaves in parallel
openrao.searchtreerao.reportEvaluatingRootLeaf = Evaluating root leaf
openrao.searchtreerao.reportExceptionMessage = ${exceptionMessage}
openrao.searchtreerao.reportExceptionMessageAndStacktrace = ${exceptionMessage} \n ${stackTrace}
openrao.searchtreerao.reportFailedOptimizationSummary = Scenario "${scenarioName}": ${raResult}
openrao.searchtreerao.reportFailedToEvaluateLeafSensiFailed = Failed to evaluate leaf: sensitivity analysis failed
openrao.searchtreerao.reportFailedToOptimizeLeaf = Failed to optimize leaf: ${leaf}
openrao.searchtreerao.reportFastRaoDoesNotSupportMultiCurativeOptimization = Fast Rao does not support multi-curative optimization
openrao.searchtreerao.reportFastRaoDoesNotSupportOptimizationOnOneGivenStateOnly = Fast Rao does not support optimization on one given state only
openrao.searchtreerao.reportFastRaoFinalResult = [FAST RAO] Final Result: cost = ${cost} (functional: ${functionalCost}, virtual: ${virtualCost}${virtualCostDetail})
openrao.searchtreerao.reportFastRaoInitialSensitivityAnalysisResults = [FAST RAO] Initial sensitivity analysis: cost = ${cost} (functional: ${functionalCost}, virtual: ${virtualCost}${virtualCostDetail})
openrao.searchtreerao.reportFastRaoIntermediateResult = [FAST RAO] Iteration ${iterationCounter}: sensitivity analysis: cost = ${cost} (functional: ${functionalCost}, virtual: ${virtualCost}${virtualCostDetail})
openrao.searchtreerao.reportFastRaoIterationRunFilteredRaoEnd = [FAST RAO] Iteration ${iterationCounter}: Run filtered RAO [end]
openrao.searchtreerao.reportFastRaoIterationRunFilteredRaoStart = [FAST RAO] Iteration ${iterationCounter}: Run filtered RAO with ${nbCnecsToKeep}/${nbCnecsInCrac} cnecs [start]
openrao.searchtreerao.reportFastRaoIterationRunFullSensitivityAnalysisEnd = [FAST RAO] Iteration ${iterationCounter}: Run full sensitivity analysis [end]
openrao.searchtreerao.reportFastRaoIterationRunFullSensitivityAnalysisStart = [FAST RAO] Iteration ${iterationCounter}: Run full sensitivity analysis [start]
openrao.searchtreerao.reportHeterogenousRangeActionGroupTypes = Range action group ${groupId} contains range actions of different types; they are not simulated
openrao.searchtreerao.reportHvdcRangeActionNotActivatedOutsideRange = HVDC range action ${hvdcRaId} could not be activated because its initial set-point (${activePowerSetpoint}) does not fall within its allowed range (${minAdmissibleSetpoint} - ${maxAdmissibleSetpoint})
openrao.searchtreerao.reportIfMostLimitingElementIsFictional = Limiting element is a fictional CNEC that is excluded from final cost computation
openrao.searchtreerao.reportImpossibleToOptimizeLeafBecauseEvaluationFailed = Impossible to optimize leaf: ${leaf} because evaluation failed
openrao.searchtreerao.reportImpossibleToOptimizeLeafBecauseEvaluationNotPerformed = Impossible to optimize leaf: ${leaf} because evaluation has not been performed
openrao.searchtreerao.reportInitialSensitivityAnalysisFailed = Initial sensitivity analysis failed
openrao.searchtreerao.reportInitialSituation = Initial situation
openrao.searchtreerao.reportInitialSituationMostLimitingElements = Limiting element #${limitingElementIndex}:${isRelativeMargin} margin = ${roundedCnecMargin} ${unit}${ptdfIfRelative}, element ${cnecNetworkElementName} at state ${cnecStateId}, CNEC ID = "${cnecId}"
openrao.searchtreerao.reportLeafAlreadyEvaluated = Leaf has already been evaluated
openrao.searchtreerao.reportLeavesToEvaluate = Leaves to evaluate: ${nbLeaves}
openrao.searchtreerao.reportLinearOptimFoundBetterSolution = Iteration ${iteration}: better solution found with a cost of ${cost} (functional: ${functionalCost})
openrao.searchtreerao.reportLinearOptimFoundWorseResult = Iteration ${iteration}: linear optimization found a worse result than best iteration, with a cost increasing from ${bestResultCost} to ${currentResultCost} (functional: from ${bestResultFunctionalCost} to ${currentResultFunctionalCost})
openrao.searchtreerao.reportLinearOptimizationAtIterationEnd = Iteration ${iteration}: linear optimization [end]
openrao.searchtreerao.reportLinearOptimizationAtIterationStart = Iteration ${iteration}: linear optimization [start]
openrao.searchtreerao.reportLinearOptimizationFailedAtIteration = Linear optimization failed at iteration ${iteration}
openrao.searchtreerao.reportLinearOptimizationOnRootLeaf = Linear optimization on root leaf
openrao.searchtreerao.reportLinearProblemFailedWithStatus = Linear problem failed with the following status : ${status}, initial situation is kept.
openrao.searchtreerao.reportLoopflowConstraintsNotRespected = Some loopflow constraints are not respected.
openrao.searchtreerao.reportMarmotApplyingOptimalTopologicalActionsOnNetworks = [MARMOT] Applying optimal topological actions on networks
openrao.searchtreerao.reportMarmotCnecs = [MARMOT] Proceeding to next iteration by adding:
openrao.searchtreerao.reportMarmotCnecsForTimestampAndVirtualCost = for timestamp ${timestamp} and virtual cost ${vcName}: ${addedCnecs}
openrao.searchtreerao.reportMarmotEvaluatingGlobalResultAfterIndependentOptimizations = [MARMOT] Evaluating global result after independent optimizations
openrao.searchtreerao.reportMarmotGlobalRangeActionsOptimization = [MARMOT] Global range actions optimization
openrao.searchtreerao.reportMarmotGlobalRangeActionsOptimizationEnd = [MARMOT] End of global range actions optimization
openrao.searchtreerao.reportMarmotGlobalRangeActionsOptimizationForIteration = [MARMOT] Global range actions optimization for iteration ${iteration}
openrao.searchtreerao.reportMarmotGlobalRangeActionsOptimizationForIterationEnd = [MARMOT] End of global range actions optimization for iteration ${iteration}
openrao.searchtreerao.reportMarmotGlobalRangeActionsOptimizationForIterationStart = [MARMOT] Starting global range actions optimization for iteration ${iteration}
openrao.searchtreerao.reportMarmotGlobalRangeActionsOptimizationStart = [MARMOT] Starting global range actions optimization
openrao.searchtreerao.reportMarmotMergingTopoAndLinearRemedialActionResults = [MARMOT] Merging topological and linear remedial action results
openrao.searchtreerao.reportMarmotNextIterationOfMip = [MARMOT] next iteration of MIP: cost = ${cost} (functional: ${functionalCost}, virtual: ${virtualCost}${virtualCostDetail})
openrao.searchtreerao.reportMarmotNoInterTemporalConstraintProvided = [MARMOT] No inter-temporal constraint provided; no need to re-optimize range actions
openrao.searchtreerao.reportMarmotResultAfterGlobalLinearOptimization = [MARMOT] After global linear optimization: cost = ${cost} (functional: ${functionalCost}, virtual: ${virtualCost}${virtualCostDetail})
openrao.searchtreerao.reportMarmotResultBeforeGlobalLinearOptimization = [MARMOT] Before global linear optimization: cost = ${cost} (functional: ${functionalCost}, virtual: ${virtualCost}${virtualCostDetail})
openrao.searchtreerao.reportMarmotResultBeforeTopologicalOptimization = [MARMOT] Before topological optimizations: cost = ${cost} (functional: ${functionalCost}, virtual: ${virtualCost}${virtualCostDetail})
openrao.searchtreerao.reportMarmotRunRaoForTimestamp = [MARMOT] Running RAO for timestamp ${timestamp}
openrao.searchtreerao.reportMarmotRunRaoForTimestampEnd = [MARMOT] End of RAO run for timestamp ${timestamp}
openrao.searchtreerao.reportMarmotRunRaoForTimestampStart = [MARMOT] Start running RAO for timestamp ${timestamp}
openrao.searchtreerao.reportMarmotSystematicInterTemporalSensitivityAnalysis = [MARMOT] Systematic inter-temporal sensitivity analysis
openrao.searchtreerao.reportMarmotSystematicInterTemporalSensitivityAnalysisEnd = [MARMOT] End of systematic inter-temporal sensitivity analysis
openrao.searchtreerao.reportMarmotSystematicInterTemporalSensitivityAnalysisStart = [MARMOT] Starting systematic inter-temporal sensitivity analysis
openrao.searchtreerao.reportMarmotTopologicalOptimization = [MARMOT] Topological optimization
openrao.searchtreerao.reportMarmotTopologicalOptimizationEnd = [MARMOT] End of topological optimization
openrao.searchtreerao.reportMarmotTopologicalOptimizationStart = [MARMOT] Starting topological optimization
openrao.searchtreerao.reportMaxSearchDepthReached = Maximum search depth has been reached, exiting search tree
openrao.searchtreerao.reportMergingFirstSecondPreventiveAndPostContingencyRaoResults = Merging first, second preventive and post-contingency RAO results
openrao.searchtreerao.reportMergingPreventiveAndPostContingencyRaoResults = Merging preventive and post-contingency RAO results
openrao.searchtreerao.reportMergingRaoAndPstRegulationResults = Merging RAO and PST regulation results
openrao.searchtreerao.reportMissingFastRaoParametersExtension = Parameters are missing FastRaoParameters extension. Default FastRaoParameters will be used
openrao.searchtreerao.reportMnecConstraintsNotRespected = Some MNEC constraints are not respected.
openrao.searchtreerao.reportMostLimitingElements = Most limiting elements
openrao.searchtreerao.reportNetworkActionCombinationsFilteredOutMaxElementaryActionsExceeded = ${nbOfCombinations} network action combinations have been filtered out because the maximum number of elementary actions has been exceeded for one of its operators
openrao.searchtreerao.reportNetworkActionCombinationsFilteredOutMaxNetworkActionsReached = ${nbOfCombinations} network action combinations have been filtered out because the maximum number of network actions for their TSO has been reached
openrao.searchtreerao.reportNetworkActionCombinationsFilteredOutMaxUsableRasReached = ${nbOfCombinations} network action combinations have been filtered out because the max number of usable RAs has been reached
openrao.searchtreerao.reportNetworkActionCombinationsFilteredOutMaxUsableTsosReached = ${nbOfCombinations} network action combinations have been filtered out because the max number of usable TSOs has been reached
openrao.searchtreerao.reportNetworkActionCombinationsFilteredOutTooFar = ${nbOfCombinations} network action combinations have been filtered out because they are too far from the most limiting element
openrao.searchtreerao.reportNoBetterResultFoundInSearchDepth = No better result found in search depth ${depth}, exiting search tree
openrao.searchtreerao.reportNoGlskFoundForCountryEICode = No GLSK found for CountryEICode ${eiCode}
openrao.searchtreerao.reportNoMoreNetworkActionAvailable = No more network action available
openrao.searchtreerao.reportNoNetworkActionAvailable = No network action available
openrao.searchtreerao.reportNoRangeActionActivated = No range actions activated
openrao.searchtreerao.reportNoRangeActionToOptimize = No range actions to optimize
openrao.searchtreerao.reportNoRangeActionToOptimizeAfterFilteringHvdcRangeActions = No range actions to optimize after filtering HVDC range actions
openrao.searchtreerao.reportNotEnoughTimeToRunSecondPreventiveRao = There is not enough time to run a 2nd preventive RAO (target end time: ${targetEndInstant}, estimated time needed based on first preventive RAO: ${estimatedPreventiveRaoTimeInSeconds} seconds)
openrao.searchtreerao.reportOptimizedLeaf = Optimized ${leaf}
openrao.searchtreerao.reportOptimizationSummaryWithInitialCost = Scenario "${scenarioName}": initial cost = ${initialCost} (functional: ${initialFunctionalCost}, virtual: ${initialVirtualCost}${initialVirtualCostDetail}), ${raResult}, cost after ${optimizedStateInstant} optimization = ${finalCost} (functional: ${finalFunctionalCost}, virtual: ${finalVirtualCost}${finalVirtualCostDetail})
openrao.searchtreerao.reportOptimizationSummaryWithoutInitialCost = Scenario "${scenarioName}": ${raResult}, cost after ${optimizedStateInstant} optimization = ${finalCost} (functional: ${finalFunctionalCost}, virtual: ${finalVirtualCost}${finalVirtualCostDetail})
openrao.searchtreerao.reportOptimizingAutomatonState = Optimizing automaton state ${automatonStateId}.
openrao.searchtreerao.reportOptimizingCurativeState = Optimizing curative state ${stateId}.
openrao.searchtreerao.reportOptimizingLeaf = Optimizing leaf...
openrao.searchtreerao.reportOptimizingScenarioPostContingency = Optimizing scenario post-contingency ${contingencyId}.
openrao.searchtreerao.reportPerimeterPurelyVirtual = Perimeter is purely virtual and virtual cost is zero. Exiting search tree.
openrao.searchtreerao.reportPostContingencyPerimeterOptimizationEnd = End of post-contingency perimeters optimization
openrao.searchtreerao.reportPostContingencyPerimeterOptimizationStart = Starting post-contingency perimeters optimization
openrao.searchtreerao.reportPostPraSensiAnalysis = Post-PRA sensitivity analysis
openrao.searchtreerao.reportPredefinedCombinationShouldContainAtLeast2NetworkActionIds = A predefined combination should contain at least 2 NetworkAction ids
openrao.searchtreerao.reportPreventivePerimeterNotSecure = Preventive perimeter could not be secured; there is no point in optimizing post-contingency perimeters. The RAO will be interrupted here.
openrao.searchtreerao.reportPreventivePerimeterOptimization = Preventive perimeter optimization
openrao.searchtreerao.reportPreventivePerimeterOptimizationEnd = End of preventive perimeter optimization
openrao.searchtreerao.reportPreventivePerimeterOptimizationStart = Starting preventive perimeter optimization
openrao.searchtreerao.reportPstRegulation = PST regulation
openrao.searchtreerao.reportPstRegulationEnd = End of PST regulation
openrao.searchtreerao.reportPstRegulationStart = Starting PST regulation
openrao.searchtreerao.reportRangeActionGroupNotAllAvailableAtAutoInstant = Range action group ${groupId} contains range actions not all available at AUTO instant; they are not simulated
openrao.searchtreerao.reportRangeActionInitialSetpointDoesNotRespectAllowedRange = Range action ${rangeActionId} has an initial setpoint of ${initialSetPoint} that does not respect its allowed range [${minSetPoint} ${maxSetPoint}]. It will be filtered out of the linear problem.
openrao.searchtreerao.reportRangeActionsActivated = Range action(s): ${rangeActions}
openrao.searchtreerao.reportRangeActionsOfGroupDoNotHaveSamePrePerimeterSetpoint = Range actions of group ${groupId} do not have the same prePerimeter setpoint. They will be filtered out of the linear problem.
openrao.searchtreerao.reportRangeActionVariation = ${rangeActionId} variation of ${variationAmount} ${variationUnit} at state ${state} (${initialValue} -> ${finalValue})
openrao.searchtreerao.reportRaoFailure = Optimizing state "${stateId}" failed: ${exception}
openrao.searchtreerao.reportRaoIncreasedOverallCost = RAO has increased the overall cost from ${initialCost} (functional: ${initialFunctionalCost}, virtual: ${initialVirtualCost}) to ${finalCost} (functional: ${finalFunctionalCost}, virtual: ${finalVirtualCost}). Falling back to initial solution.
openrao.searchtreerao.reportRemainingLeavesToEvaluate = Remaining leaves to evaluate: ${nbLeaves}
openrao.searchtreerao.reportRemainingPostContingencyScenariosToOptimize = Remaining post-contingency scenarios to optimize: ${nbOfRemainingScenarios}
openrao.searchtreerao.reportResetRangeActionSetpoints = Resetting range action setpoints to their pre-optim values
openrao.searchtreerao.reportRootLeaf = ${rootLeaf}
openrao.searchtreerao.reportRunLoadFlowForHvdcAngleDroopActivePowerControlSetPoint = Running load-flow computation to access HvdcAngleDroopActivePowerControl set-point values.
openrao.searchtreerao.reportRunPostRangeSensitivityAnalysisForStateAndSpeed = Running post range automatons sensitivity analysis after auto state ${automatonStateId} for speed ${speed}.
openrao.searchtreerao.reportRunSensitivityAnalysisAfterDisablingAngleDroopActivePowerControlOnHvdcRa = Running sensitivity analysis after disabling AngleDroopActivePowerControl on HVDC RAs.
openrao.searchtreerao.reportRunSensitivityAnalysisPostApplicationForStateAndSpeed = Running sensitivity analysis post application of auto network actions for automaton state ${automatonStateId} for speed ${speed}.
openrao.searchtreerao.reportSameResultAsPreviousIterations = Iteration ${iteration}: same results as previous iterations, optimal solution found
openrao.searchtreerao.reportSearchDepth = Search depth ${depth}
openrao.searchtreerao.reportSearchDepthBestLeaf = Search depth ${depth} best leaf: ${leaf}
openrao.searchtreerao.reportSearchDepthEnd = End of search depth ${depth}
openrao.searchtreerao.reportSearchDepthStart = Starting search depth ${depth}
openrao.searchtreerao.reportSecondAutomatonSimulation = Second automaton simulation
openrao.searchtreerao.reportSecondAutomatonSimulationEnd = End of second automaton simulation
openrao.searchtreerao.reportSecondAutomatonSimulationStart = Starting second automaton simulation
openrao.searchtreerao.reportSecondPreventiveCancelledToSaveComputationTime = First preventive RAO was not able to fix all preventive constraints, second preventive RAO cancelled to save computation time.
openrao.searchtreerao.reportSecondPreventiveFailed = Second preventive failed. Falling back to previous solution.
openrao.searchtreerao.reportSecondPreventiveIncreasedOverallCost = Second preventive step has increased the overall cost from ${firstPreventiveCost} (functional: ${firstPreventiveFunctionalCost}, virtual: ${firstPreventiveVirtualCost}) to ${secondPreventiveCost} (functional: ${secondPreventiveFunctionalCost}, virtual: ${secondPreventiveVirtualCost}). Falling back to previous solution.
openrao.searchtreerao.reportSecondPreventiveMadeRaoSucceed = RAO has succeeded thanks to second preventive step when first preventive step had failed
openrao.searchtreerao.reportSecondPreventivePerimeterOptimization = Second preventive perimeter optimization
openrao.searchtreerao.reportSecondPreventivePerimeterOptimizationEnd = End of second preventive perimeter optimization
openrao.searchtreerao.reportSecondPreventivePerimeterOptimizationStart = Starting second preventive perimeter optimization
openrao.searchtreerao.reportSearchDepthBestLeafNoRangeActionActivated = Search depth ${depth} best leaf: No range actions activated
openrao.searchtreerao.reportSearchDepthBestLeafRangeActionsActivated = Search depth ${depth} best leaf: Range action(s): ${rangeActions}
openrao.searchtreerao.reportSearchTreeRaoCompletedWithStatus = Search-tree RAO completed with status ${status}
openrao.searchtreerao.reportShiftSetPointOfRangeActionToSecureCnecOnSide = Shifting set-point from ${currentSetpoint} to ${optimalSetpoint} on range action(s) ${raIds} to secure CNEC ${cnecId} on side ${side} (current margin: ${cnecMargin} MW).
openrao.searchtreerao.reportSimulatingAutomatonBatch = Simulating automaton batch of speed ${speed} for automaton state ${automatonStateId}
openrao.searchtreerao.reportSkippingOptimization = Skipping ${id} optimization because earlier combination fulfills stop criterion.
openrao.searchtreerao.reportSolverInterrupted = The solver was interrupted. A feasible solution has been produced.
openrao.searchtreerao.reportStopCriterionCouldHaveBeenReachedWithoutVirtualCostOptimized = Optimized ${leaf}, stop criterion could have been reached without "${virtualCostName}" virtual cost
openrao.searchtreerao.reportStopCriterionCouldHaveBeenReachedWithoutVirtualCost = ${leaf}, stop criterion could have been reached without "${virtualCostName}" virtual cost
openrao.searchtreerao.reportStopCriterionReached = Stop criterion reached, other threads may skip optimization.
openrao.searchtreerao.reportStopCriterionReachedOnLeaf = Stop criterion reached on ${leaf}
openrao.searchtreerao.reportSystematicSensitivityAnalysisAfterCraAfterSecondPreventiveFailed = Systematic sensitivity analysis after curative remedial actions after second preventive optimization failed
openrao.searchtreerao.reportSystematicSensitivityAnalysisAfterPraAfterSecondPreventiveFailed = Systematic sensitivity analysis after preventive remedial actions after second preventive optimization failed
openrao.searchtreerao.reportSystematicSensitivityAnalysisAfterPraFailed = Systematic sensitivity analysis after preventive remedial actions failed
openrao.searchtreerao.reportSystematicSensitivityComputationFailedAtIteration = Systematic sensitivity computation failed at iteration ${iteration}
openrao.searchtreerao.reportUnknownNetworkActionIdInPredefinedCombinationsParameter = Unknown network action id in predefined-combinations parameter: ${networkActionId}
openrao.searchtreerao.reportVirtualCostlyElement = ${leafId}, limiting "${virtualCostName}" constraint #${costlyElementIndex}: flow = ${flow} ${flowUnit}, threshold = ${threshold} ${thresholdUnit}, margin = ${margin} ${marginUnit}, element ${networkElement} at state ${state}, CNEC ID = "${cnecId}", CNEC name = "${cnecName}"
openrao.searchtreerao.reportVirtualCostlyElementOptimized = Optimized ${leafId}, limiting "${virtualCostName}" constraint #${costlyElementIndex}: flow = ${flow} ${flowUnit}, threshold = ${threshold} ${thresholdUnit}, margin = ${margin} ${marginUnit}, element ${networkElement} at state ${state}, CNEC ID = "${cnecId}", CNEC name = "${cnecName}"
